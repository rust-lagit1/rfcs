- Feature Name: out
- Start Date: Tue Mar 10 23:39:14 CET 2015
- RFC PR: (leave this empty)
- Rust Issue: (leave this empty)

# Summary

Add reference and slice types that take ownership of the objects they reference.

# Examples

```rust
fn f() {
    let x: String = String::new();
    let x_ref: &out String = &out x;
    let y: String = *x_ref;
}

fn g() {
    let xs: [String; 2] = [String::new(), String::new()];
    let x_refs: &out [String] = &out xs[..];
    let ys: Vec<String> = x_refs.into_iter().collect();
}
```

# Motivation

Today it is not easily possible to express the idea of a reference that you can
move out of. It can be emulated with enums:

```rust
fn f() {
    let x: Option<String> = Some(String::new());
    let x_ref: &mut Option<String> = &mut x;
    let y: String = x_ref.take().unwrap();
}
```

There are some disadvantages related to performance and ergonomics:

- Having to use `Some(variable)` to create a movable reference is inconvenient.
- `&mut Option<T>` is uglier than `&out T`.
- In the code above, the destructors of both `x` and `y` will have to run even
  though the `String` has been moved out of `x`.
- `&mut Option<T>` is not safe in the way references are safe in Rust. A `&T`
  always points to a valid `T`. A `&mut Option<T>` can point to `None`. The
  receiver either has to deal with panics or check (and handle) the presence of
  `None`. (Similar to languages such as C# where you can get
  `NullReferenceExceptions`.)

Another problem are traits. The following is currently not possible:

```rust
trait GivesYouAString {
    fn string(self) -> String;
}

impl GivesYouAString for String {
    fn string(self) -> String { self }
}

fn f() {
    let x = String::new();
    let y = &mut x as &mut GivesYouAString; // not object safe
    let z = y.string(); // cannot move out of mutable reference
}
```

With `&out` this would be easy:

```rust
trait GivesYouAString {
    fn string(&out self) -> String;
}

impl GivesYouAString for String {
    fn string(&out self) -> String { *self }
}

fn f() {
    let x = String::new();
    let y = &out x as &out GivesYouAString;
    let z = y.string();
}
```

Right now you can work around this by using:

```rust
impl GivesYouAString for String {
    fn string(self: Box<Self>) -> String { *self }
}

// ...

    let y = Box::new(x) as Box<GivesYouAString>;
    let z = y.string();
}
```

but this requires an additional allocation.

A practical use case of this is the `Any` trait. With move semantics we can pass
an arbitrary type to a function and consume the contained object:

```rust
fn append_hello_world(x: &out Any) -> String {
    if x.is::<String>() {
        x.downcast_move::<String>().unwrap().push("hello world")
    } else if x.is::<i32>() {
        x.downcast_move::<i32>().unwrap().to_string().push("hello world")
    } else {
        String::new("hello world")
    }
}
```

----

For slices the situation is somewhat worse. To move out of a slice, the user has
to replace every element in the slice by `Option<T>`. If the size of the slice
is unknown at compile time, then this requires a `Vec<Option<T>>` allocation.
Combining all of these aspects, one might as well just pass a `Vec<T>` directly.

With `&out` slices and pointers it's quite easy to implement variadic functions
that take arbitrary, type-safe, arguments.

```rust
/// Collects all of the arguments that are strings into a vector.
fn collect_strings(args: &out [&out Any]) -> Vec<String> {
    let mut strings = vec!();
    for arg in args.into_iter() {
        if arg.is::<String>() {
            let string = x.downcast_move::<String>().unwrap();
            strings.push(string);
        }
    }
    strings
}
```

which can be used like this:

```rust
fn f() {
    let arg1 = String::new();
    let arg2 = 1u32;
    let arg3 = String::new();
    let strings = collect_strings(&out [&out arg1, &out arg2, &out arg3][..]);
}
```

---

Even without `&out` slices it is possible to implement variadic functions with
a little bit of compiler magic:

```rust
fn f(args: ..&out Any) {
    // args is an anonymous type that implements Iterator<Item=&out Any>
}

fn g() {
    let arg1 = String::new();
    let arg2 = 1u32;
    let arg3 = String::new();
    f(&out arg1, &out arg2, &out arg3);
}
```

If `Any` were a built-in type, then this could even be simplified to

```rust
fn f(args: ..) {
    // args is an anonymous type that implements Iterator<Item=&out Any>
}

fn g() {
    let arg1 = String::new();
    let arg2 = 1u32;
    let arg3 = String::new();
    f(arg1, arg2, arg3);
}
```

But this is somewhat off-topic.

# Detailed design

A `&out T` reference looks exactly like a `&mut T` reference, i.e., if `T` is a
sized type, then it's simply a pointer to the referenced data. If `T` is a
trait or slice (`[U]`), then it's a fat pointer.

A `&out T` reference behaves exactly like a `&mut T` reference except that you
can move out of it via dereferencing. This consumes the reference. If the
reference is not explicitly consumed, the compiler will consume the reference
implicitly. For example:

```rust
fn f(_x: &out String) {
}
```

Modulo optimization, this is equivalent to

```rust
fn f(_x: &out String) {
    let _unused = *_x;
}
```

Creating a `&out T` reference makes the referenced object indefinitely
inaccessible except through the `&out` reference.

```rust
fn f(x: String) {
    {
        let _y = &out x;
    }
    x.push(""); // error: x has been moved
}
```

Creating a `&out T` reference moves the drop obligation for the referenced
object into the reference. For example:

```rust
fn f(x: String, flag: bool) {
    if flag {
        g(&out x);
    } else {
        h();
    }
}
```

Assuming non-zeroing drop, the compiler will generate the following pseudo code:

```rust
fn f(x: String, flag: bool) {
    let mut x_needs_drop = true;

    if flag {
        x_needs_drop = false;
        g(&out x);
    } else {
        h();
    }

    if x_needs_drop {
        drop x;
        // This is pseudo code because the user cannot access `x` at this point.
    }
}
```

Creating a `&out T` reference, however, does not move the drop obligation for
the container into the reference. For example:

```rust
fn f(x: Box<String>, flag: bool) {
    if flag {
        g(&out *x);
    } else {
        h();
    }
}
```

Again assuming non-zeroing drops, the compiler generates

```rust
fn f(x: Box<String>, flag: bool) {
    let mut x_needs_drop = true;

    if flag {
        x_needs_drop = false;
        g(&out *x);
    } else {
        h();
    }

    if x_needs_drop {
        drop *x;
    }
    deallocate(x);
}
```

This means that there are two drop flags: One for the container and one for the
contained object. (With zeroing drops both of these flags are implicit.)

It's possible to take a sub-`&out` reference if the type does not implement
`Drop`. For example:

```rust
struct X {
    a: String,
    b: String,
}

fn f(x: &out X) -> &out String {
    &out x.b
}

// This is equivalent to

fn g(x: &out X) -> &out String {
    let X { a: _, b: ref out b } = *x;
    b
}

// One could even write

fn h(x: &out X) -> (&out String, &out String) {
    let a = &out x.a;
    let b = &out x.b;
    (a, b)
}
```

A `&out T` supports implicit coercions to `&mut T` and `&T`:

```rust
fn f(x: String) {
    g(&out x);
    // implicit move out of the anonymous reference here
}

fn g(x: &mut T) {
}
```

Similarly,

```rust
trait DerefOut {
    type Target;

    fn deref_out(&out self) -> &out Target;
}
```

supports deref coercion between `&out` references.

## Custom containers

Rust currently does not support custom containers, e.g., you cannot do things
like

```rust
fn f(x: Container<String>) {
    let y: String = *x;
}
```

This is because the `Drop` implementation of `Container<String>` cannot
distinguish between cases where it has to drop the contained string and where
the string has been moved out.

Note that `Box` is a special compiler built-in type for this reason.

This limits the usefulness of `DerefMove` because you cannot `deref_out` if the
container has a custom `Drop` implementation.

## Slices

Even though slices are not special, we'll describe the behavior that can be
expected from `&out [T]` slices here:

Subslicing causes the objects that are no longer in the slice to be dropped.

Taking a move reference to a single element causes all other elements to be
dropped:

```rust
fn f(xs: &out [String]) {
    let x = &out xs[0];
}
```

At this point, it's not possible to create `&out` slices from anything but
`[T; N]` and `Box<[T]>`. This is because of the custom container restriction
mentioned in the section above.

# Drawbacks

`&out` slices are very limited at the moment. Once Rust supports custom
containers they become more powerful.

# Alternatives

## What other designs have been considered?

None

## What is the impact of not doing this?

Can't move out of references.

# Unresolved questions

None right now.
